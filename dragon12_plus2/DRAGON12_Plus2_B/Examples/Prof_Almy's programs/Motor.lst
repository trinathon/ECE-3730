as12, an absolute assembler for Motorola MCU's, version 1.2e

                        ;
                        ; Motor Speed Control Example Program
                        ; Author: Tom Almy
                        ; Date:   May 22, 2007
                        ; Copyright 2007, Tom Almy. Permission given to copy for use
                        ; in Wytec Dragon12-plus board.
                        
                        ; Function:
                        ; The user enters the desired speed and direction using the keypad.
                        ; 0 through 9 set the speed (stop to full speed). The * button sets
                        ; forward direction and the # button sets reverse direction. The lower
                        ; right button on the keypad turns the driver off.
                        
                        ; In the DC motor version, the motor connects between the MOT1 and MOT2 terminals.
                        ; In the (bipolar) stepper motor version, one winding connects between the MOT1 and MOT2
                        ; terminals while the second winding connects between the MOT3 and MOT4 terminals.
                        ; For the stepper motor, this code will by default give a step rate of 10 to 90 steps/second.
                        
                        ; The board must be configured for the desired motor power voltage and source. 
                        
                        ; Implementation:
                        ; An RTI interrupt at roughly 1mSec rate does the keypad polling and LCD display driving.
                        ; This code is taken from the keypad and frequency meter examples in the Designing with
                        ; Microcontrollers textbook. The subroutine getkey reads the keypad value and blocks if no
                        ; key is available. There is a single byte buffer for the keypad value. The LCD display driver
                        ; is interrupt driven so that the timing delays won't interfere with the control of the motors.
                        ; The subroutines lcd_line1 and lcd_line2 position the cursor at the start of the first and
                        ; second lines, respectively, while msg_out displays the 0-byte terminated character string
                        ; passed to it in X, and putlcd displays the character passed to it in A. These functions will
                        ; block only if the 32 byte buffer is filled, so typically an entire message can be queued for
                        ; display without blocking.
                        
                        ; The main routine ("idle process") reads the key presses, saves the command in variables running, 
                        ; reverse, and speed, then updates the LCD display by writing a new status message.
                        
                        ; In the DC motor version, a PWM channel is used to control the speed. Since the PWM generates a
                        ; continuous pulse train without program intervention, the main routine has additional code to
                        ; set the direction (by changing the H-Bridge inputs) and speed (by changing the pulse width).
                        
                        ; In the stepper motor version, a timer channel interrupt is used to advance the H-Bridge through the
                        ; four phases. The LED row display shows the values for the driver enables (bits 7 and 6) and
                        ; the motor drives (bits 3 to 0).
                        
                        ;DC_MOTOR 	equ 1          	; Define for DC motor version
0001                    STEPPER_MOTOR 	equ 1   	; Define for Stepper motor version
                        
                        ;RTI_DIVIDER	equ	$13     ; use this for 4 MHz crystal, RTI divider is 4096, about 1 mSec
0017                    RTI_DIVIDER	equ	$17     ; use this for 8 MHz crystal, RTI divider is 8192, about 1 mSec
                        
                        #include        registers.inc   ; include register equates
                        ; Memory maps and register equates
                        ; Choose one of DBUG12MAP (normal operation under DBUG12)
                        ;               EEPROMMAP  (DBUG12 in EEPROM mode)
                        ;               FLASHMAP   (Program loaded into Flash ROM)
0000                    DBUG12MAP equ 0	; Memory mode is DBUG12MAP
                        ; EEPROMMAP equ 0         ; Memory mode is EEPROMMAP
                        #ifdef DBUG12MAP
0000                    REGBASE	equ	$0	; register base
1000                    DATASTART equ	$1000	; Start of data memory
2000                    DATAEND  equ	$2000	; Stack pointer initial value (end of data RAM area)
2000                    PRSTART equ	$2000	; Start of program memory (might be ROM)
3bff                    PREND	equ	$3BFF	; End of program memory
                        
                        ; Functions in D-Bug12
ee84                    Getchar	equ	$EE84	; Implemented in emulator
ee86                    Putchar equ	$EE86   ; Implemented in emulator
ee88                    Printf  equ     $EE88
ee8a                    GetCmdLine equ  $EE8A   ; FAR call
ee8e                    Sscanhex equ	$EE8E   ; FAR call
ee92                    Isxdigit equ    $EE92
ee94                    Toupper equ     $EE94
ee96                    Isalpha equ     $EE96
ee98                    Strlen  equ     $EE98
ee9a                    Strcpy  equ     $EE9A
ee9c                    Out2hex equ     $EE9C   ; FAR call
eea0                    Out4hex equ     $EEA0   ; FAR call
eea4                    SetUserVector equ $EEA4 ; No longer used
eea6                    WriteEEByte equ $EEA6   ; FAR call
eeaa                    EraseEE equ     $EEAA   ; FAR call
eeae                    ReadMem equ     $EEAE   ; FAR call
eeb2                    WriteMem equ    $EEB2   ; FAR call
                        
3e00                    VECTORTABLE equ $3E00	; Vectors go here SHOULD ALSO INITIALIZE AT RUNTIME
0000                    STATICVECTORS equ 0	; Define vectors statically (in "ROM")
0000                    INITIALIZEVECTORS equ 0	; Initialize vectors at runtime
                        #endif
                        
                        #ifdef EEPROMMAP
                        REGBASE	equ	$0	; register base MAY BE MOVED TO MAKE FULL EEPROM ACCESSABLE
                        DATASTART equ	$1000	; Start of data memory
                        DATAEND  equ	$3E00	; Stack pointer initial value (end of data RAM area)
                        PRSTART equ	$400	; Start of program memory
                        PREND	equ	$FFF	; End of program memory
                        
                        VECTORTABLE equ $3E00	; Vectors go here -- MUST BE INITIALIZED AT RUNTIME
                        INITIALIZEVECTORS equ 0	; Initialize vectors at runtime
                        #endif
                        
                        #ifdef FLASHMAP
                        REGBASE	equ	$0	; register base MAY BE MOVED TO MAKE FULL EEPROM ACCESSABLE
                        DATASTART equ	$1000	; Start of data memory
                        DATAEND  equ	$4000	; Stack pointer initial value (end of data RAM area)
                        PRSTART equ	$8000	; Start of program memory
                        ; Note -- there are problems using the current free assemblers with paged memory
                        ; Best bet is to use logical addresses $8000 up only, set page register to 3E,
                        ; Change S1 records for $8000-BFFF to S2 records for page 3E and S1 records for $C000-$EFFF to
                        ; page 3F. Program startup vector goes in EFFE, and needs to be iin page 3F so PPAGE can be changed. 
                        PREND	equ	$EF7F	; End of program memory
                        
                        VECTORTABLE equ $EF80	; Vectors go here -- MUST BE INITIALIZED STATICALLY
                        STATICVECTORS equ 0	; Define vectors statically (in "ROM")
                        #endif
                        
                        
1000                    RAMSTART equ	DATASTART ; For compatibility
2000                    RAMEND equ	DATAEND   
                        
3e00                    UserRsrv0x80 equ (0*2)+VECTORTABLE
3e02                    UserRsrv0x82 equ (1*2)+VECTORTABLE
3e04                    UserRsrv0x84 equ (2*2)+VECTORTABLE
3e06                    UserRsrv0x86 equ (3*2)+VECTORTABLE
3e08                    UserRsrv0x88 equ (4*2)+VECTORTABLE
3e0a                    UserRsrv0x8a equ (5*2)+VECTORTABLE
3e0c                    UserPWMShDn equ (6*2)+VECTORTABLE
3e0e                    UserPortP equ (7*2)+VECTORTABLE
3e10                    UserMSCAN4Tx equ (8*2)+VECTORTABLE
3e12                    UserMSCAN4Rx equ (9*2)+VECTORTABLE
3e14                    UserMSCAN4Errs equ (10*2)+VECTORTABLE
3e16                    UserMSCAN4Wake equ (11*2)+VECTORTABLE
3e18                    UserMSCAN3Tx equ (12*2)+VECTORTABLE
3e1a                    UserMSCAN3Rx equ (13*2)+VECTORTABLE
3e1c                    UserMSCAN3Errs equ (14*2)+VECTORTABLE
3e1e                    UserMSCAN3Wake equ (15*2)+VECTORTABLE
3e20                    UserMSCAN2Tx equ (16*2)+VECTORTABLE
3e22                    UserMSCAN2Rx equ (17*2)+VECTORTABLE
3e24                    UserMSCAN2Errs equ (18*2)+VECTORTABLE
3e26                    UserMSCAN2Wake equ (19*2)+VECTORTABLE
3e28                    UserMSCAN1Tx equ (20*2)+VECTORTABLE
3e2a                    UserMSCAN1Rx equ (21*2)+VECTORTABLE
3e2c                    UserMSCAN1Errs equ (22*2)+VECTORTABLE
3e2e                    UserMSCAN1Wake equ (23*2)+VECTORTABLE
3e30                    UserMSCAN0Tx equ (24*2)+VECTORTABLE
3e32                    UserMSCAN0Rx equ (25*2)+VECTORTABLE
3e34                    UserMSCAN0Errs equ (26*2)+VECTORTABLE
3e36                    UserMSCAN0Wake equ (27*2)+VECTORTABLE
3e38                    UserFlash equ (28*2)+VECTORTABLE
3e3a                    UserEEPROM equ (29*2)+VECTORTABLE
3e3c                    UserSPI2 equ (30*2)+VECTORTABLE
3e3e                    UserSPI1 equ (31*2)+VECTORTABLE
3e40                    UserIIC equ (32*2)+VECTORTABLE
3e42                    UserDLC equ (33*2)+VECTORTABLE
3e44                    UserSCME equ (34*2)+VECTORTABLE
3e46                    UserCRG equ (35*2)+VECTORTABLE
3e48                    UserPAccBOv equ (36*2)+VECTORTABLE
3e4a                    UserModDwnCtr equ (37*2)+VECTORTABLE
3e4c                    UserPortH equ (38*2)+VECTORTABLE
3e4e                    UserPortJ equ (39*2)+VECTORTABLE
3e50                    UserAtoD1 equ (40*2)+VECTORTABLE
3e52                    UserAtoD0 equ (41*2)+VECTORTABLE
3e54                    UserSCI1 equ (42*2)+VECTORTABLE
3e56                    UserSCI0 equ (43*2)+VECTORTABLE
3e58                    UserSPI0 equ (44*2)+VECTORTABLE
3e5a                    UserPAccEdge equ (45*2)+VECTORTABLE
3e5c                    UserPAccOvf equ (46*2)+VECTORTABLE
3e5e                    UserTimerOvf equ (47*2)+VECTORTABLE
3e60                    UserTimerCh7 equ (48*2)+VECTORTABLE
3e62                    UserTimerCh6 equ (49*2)+VECTORTABLE
3e64                    UserTimerCh5 equ (50*2)+VECTORTABLE
3e66                    UserTimerCh4 equ (51*2)+VECTORTABLE
3e68                    UserTimerCh3 equ (52*2)+VECTORTABLE
3e6a                    UserTimerCh2 equ (53*2)+VECTORTABLE
3e6c                    UserTimerCh1 equ (54*2)+VECTORTABLE
3e6e                    UserTimerCh0 equ (55*2)+VECTORTABLE
3e70                    UserRTI equ (56*2)+VECTORTABLE
3e72                    UserIRQ equ (57*2)+VECTORTABLE
3e74                    UserXIRQ equ (58*2)+VECTORTABLE
3e76                    UserSWI equ (59*2)+VECTORTABLE
3e78                    UserTrap equ (60*2)+VECTORTABLE
                        
                        
                        *
                        *
                        *  HC12 i/o register locations (9s12dp256)
                        *
                        *
0000                    PORTA:          equ REGBASE+0   ;port a = address lines a8 - a15
0001                    PORTB:          equ REGBASE+1   ;port b = address lines a0 - a7
0002                    DDRA:           equ REGBASE+2   ;port a direction register
0003                    DDRB:           equ REGBASE+3   ;port b direction register
                        
0008                    PORTE:          equ REGBASE+8   ;port e = mode,irq and control signals
0009                    DDRE:           equ REGBASE+9   ;port e direction register
000a                    PEAR:           equ REGBASE+$a  ;port e assignments
000b                    MODE:           equ REGBASE+$b  ;mode register
000c                    PUCR:           equ REGBASE+$c  ;port pull-up control register
000d                    RDRIV:          equ REGBASE+$d  ;port reduced drive control register
000e                    EBICTL:		equ REGBASE+$e  ;e stretch control
                        
0010                    INITRM:         equ REGBASE+$10 ;ram location register
0011                    INITRG:         equ REGBASE+$11 ;register location register
0012                    INITEE:         equ REGBASE+$12 ;eeprom location register
0013                    MISC:           equ REGBASE+$13 ;miscellaneous mapping control
0014                    MTST0:          equ REGBASE+$14 ; reserved
0015                    ITCR:           equ REGBASE+$15 ;interrupt test control register
0016                    ITEST:          equ REGBASE+$16 ;interrupt test register
0017                    MTST1:          equ REGBASE+$17 ; reserved
                        
001a                    PARTIDH:	equ REGBASE+$1a ;part id high
001b                    PARTIDL:	equ REGBASE+$1b ;part id low
001c                    MEMSIZ0:	equ REGBASE+$1c ;memory size
001d                    MEMSIZ1:	equ REGBASE+$1d ;memory size
001e                    IRQCR:          equ REGBASE+$1e ;interrupt control register
001e                    INTCR:          equ REGBASE+$1e ;interrupt control register (old name)
001f                    HPRIO:          equ REGBASE+$1f ;high priority reg
                        
0028                    BKPCT0:         equ REGBASE+$28 ;break control register
0029                    BKPCT1:         equ REGBASE+$29 ;break control register
002a                    BKP0X:          equ REGBASE+$2a ; break 0 index register
002b                    BKP0H:          equ REGBASE+$2b ; break 0 pointer high
002c                    BRP0L:          equ REGBASE+$2c ; break 0 pointer low
002d                    BKP1X:          equ REGBASE+$2d ; break 1 index register
002e                    BKP1H:          equ REGBASE+$2e ; break 1 pointer high
002f                    BRP1L:          equ REGBASE+$2f ; break 1 pointer low
0030                    PPAGE:		equ REGBASE+$30 ;program page register
                        
0032                    PORTK:		equ REGBASE+$32 ;port k data
0033                    DDRK:		equ REGBASE+$33 ;port k direction
                        
0034                    SYNR:           equ REGBASE+$34 ; synthesizer / multiplier register
0035                    REFDV:          equ REGBASE+$35 ; reference divider register
0036                    CTFLG:          equ REGBASE+$36 ; reserved
0037                    CRGFLG:         equ REGBASE+$37 ; pll flags register
0038                    CRGINT:         equ REGBASE+$38 ; pll interrupt register
0039                    CLKSEL:         equ REGBASE+$39 ; clock select register
003a                    PLLCTL:         equ REGBASE+$3a ; pll control register
003b                    RTICTL:         equ REGBASE+$3b ;real time interrupt control
003c                    COPCTL:         equ REGBASE+$3c ;watchdog control
003d                    FORBYP:         equ REGBASE+$3d ;
003e                    CTCTL:          equ REGBASE+$3e ;
003f                    ARMCOP:         equ REGBASE+$3f ;cop reset register
                        
0040                    TIOS:           equ REGBASE+$40 ;timer input/output select
0041                    CFORC:          equ REGBASE+$41 ;timer compare force
0042                    OC7M:           equ REGBASE+$42 ;timer output compare 7 mask
0043                    OC7D:           equ REGBASE+$43 ;timer output compare 7 data
0044                    TCNT:           equ REGBASE+$44 ;timer counter register hi
                        *TCNT:          equ REGBASE+$45 ;timer counter register lo
0046                    TSCR:           equ REGBASE+$46 ;timer system control register (Old Name)
0046                    TSCR1:          equ REGBASE+$46 ;timer system control register
0047                    TTOV:           equ REGBASE+$47 ;reserved
0048                    TCTL1:          equ REGBASE+$48 ;timer control register 1
0049                    TCTL2:          equ REGBASE+$49 ;timer control register 2
004a                    TCTL3:          equ REGBASE+$4a ;timer control register 3
004b                    TCTL4:          equ REGBASE+$4b ;timer control register 4
004c                    TMSK1:          equ REGBASE+$4c ;timer interrupt mask 1 (Old Name)
004c                    TIE:            equ REGBASE+$4c ;timer interrupt mask 1
004d                    TMSK2:          equ REGBASE+$4d ;timer interrupt mask 2 (Old Name)
004d                    TSCR2:          equ REGBASE+$4d ;timer interrupt mask 2
004e                    TFLG1:          equ REGBASE+$4e ;timer flags 1
004f                    TFLG2:          equ REGBASE+$4f ;timer flags 2
0050                    TC0:            equ REGBASE+$50 ;timer capture/compare register 0
0052                    TC1:            equ REGBASE+$52 ;timer capture/compare register 1
0054                    TC2:            equ REGBASE+$54 ;timer capture/compare register 2
0056                    TC3:            equ REGBASE+$56 ;timer capture/compare register 3
0058                    TC4:            equ REGBASE+$58 ;timer capture/compare register 4
005a                    TC5:            equ REGBASE+$5a ;timer capture/compare register 5
005c                    TC6:            equ REGBASE+$5c ;timer capture/compare register 6
005e                    TC7:            equ REGBASE+$5e ;timer capture/compare register 7
0060                    PACTL:          equ REGBASE+$60 ;pulse accumulator controls
0061                    PAFLG:          equ REGBASE+$61 ;pulse accumulator flags
0062                    PACN3:          equ REGBASE+$62 ;pulse accumulator counter 3
0063                    PACN2:          equ REGBASE+$63 ;pulse accumulator counter 2
0064                    PACN1:          equ REGBASE+$64 ;pulse accumulator counter 1
0065                    PACN0:          equ REGBASE+$65 ;pulse accumulator counter 0
0066                    MCCTL:          equ REGBASE+$66 ;modulus down conunter control
0067                    MCFLG:          equ REGBASE+$67 ;down counter flags
0068                    ICPAR:          equ REGBASE+$68 ;input pulse accumulator control
0069                    DLYCT:          equ REGBASE+$69 ;delay count to down counter
006a                    ICOVW:          equ REGBASE+$6a ;input control overwrite register
006b                    ICSYS:          equ REGBASE+$6b ;input control system control
                        
006d                    TIMTST:         equ REGBASE+$6d ;timer test register
                        
0070                    PBCTL:          equ REGBASE+$70 ; pulse accumulator b control
0071                    PBFLG:          equ REGBASE+$71 ; pulse accumulator b flags
0072                    PA3H:           equ REGBASE+$72 ; pulse accumulator holding register 3
0073                    PA2H:           equ REGBASE+$73 ; pulse accumulator holding register 2
0074                    PA1H:           equ REGBASE+$74 ; pulse accumulator holding register 1
0075                    PA0H:           equ REGBASE+$75 ; pulse accumulator holding register 0
0076                    MCCNT:          equ REGBASE+$76 ; modulus down counter register
                        *MCCNTL:        equ REGBASE+$77 ; low byte
0078                    TCOH:           equ REGBASE+$78 ; capture 0 holding register
007a                    TC1H:           equ REGBASE+$7a ; capture 1 holding register
007c                    TC2H:           equ REGBASE+$7c ; capture 2 holding register
007e                    TC3H:           equ REGBASE+$7e ; capture 3 holding register
                        
0080                    ATD0CTL0:       equ REGBASE+$80 ;adc control 0 (reserved)
0081                    ATD0CTL1:       equ REGBASE+$81 ;adc control 1 (reserved)
0082                    ATD0CTL2:       equ REGBASE+$82 ;adc control 2
0083                    ATD0CTL3:       equ REGBASE+$83 ;adc control 3
0084                    ATD0CTL4:       equ REGBASE+$84 ;adc control 4
0085                    ATD0CTL5:       equ REGBASE+$85 ;adc control 5
0086                    ATD0STAT0:      equ REGBASE+$86 ;adc status register hi
008b                    ATD0STAT1:      equ REGBASE+$8b ;adc status register lo
0088                    ATD0TEST:       equ REGBASE+$88 ;adc test (reserved)
                        *atd0test       equ REGBASE+$89 ;
                        
008d                    ATD0DIEN:	equ REGBASE+$8d ;
                        
008f                    PORTAD:         equ REGBASE+$8f ;port adc = input only
0090                    ADR00H:         equ REGBASE+$90 ;adc result 0 register
0092                    ADR01H:         equ REGBASE+$92 ;adc result 1 register
0094                    ADR02H:         equ REGBASE+$94 ;adc result 2 register
0096                    ADR03H:         equ REGBASE+$96 ;adc result 3 register
0098                    ADR04H:         equ REGBASE+$98 ;adc result 4 register
009a                    ADR05H:         equ REGBASE+$9a ;adc result 5 register
009c                    ADR06H:         equ REGBASE+$9c ;adc result 6 register
009e                    ADR07H:         equ REGBASE+$9e ;adc result 7 register
                        
00a0                    PWME:		equ REGBASE+$a0 ;pwm enable
00a1                    PWMPOL:         equ REGBASE+$a1 ;pwm polarity
00a2                    PWMCLK:         equ REGBASE+$a2 ;pwm clock select register
00a3                    PWMPRCLK:       equ REGBASE+$a3 ;pwm prescale clock select register
00a4                    PWMCAE:         equ REGBASE+$a4 ;pwm center align select register
00a5                    PWMCTL:         equ REGBASE+$a5 ;pwm control register
00a6                    PWMTST:         equ REGBASE+$a6 ;reserved
00a7                    PWMPRSC:        equ REGBASE+$a7 ;reserved
00a8                    PWMSCLA:        equ REGBASE+$a8 ;pwm scale a
00a9                    PWMSCLB:        equ REGBASE+$a9 ;pwm scale b
00aa                    PWMSCNTA:       equ REGBASE+$aa ;reserved
00ab                    PWMSCNTB:       equ REGBASE+$ab ;reserved
00ac                    PWMCNT0:        equ REGBASE+$ac ;pwm channel 0 counter
00ad                    PWMCNT1:        equ REGBASE+$ad ;pwm channel 1 counter
00ae                    PWMCNT2:        equ REGBASE+$ae ;pwm channel 2 counter
00af                    PWMCNT3:        equ REGBASE+$af ;pwm channel 3 counter
00b0                    PWMCNT4:        equ REGBASE+$b0 ;pwm channel 4 counter
00b1                    PWMCNT5:        equ REGBASE+$b1 ;pwm channel 5 counter
00b2                    PWMCNT6:        equ REGBASE+$b2 ;pwm channel 6 counter
00b3                    PWMCNT7:        equ REGBASE+$b3 ;pwm channel 7 counter
00b4                    PWMPER0:        equ REGBASE+$b4 ;pwm channel 0 period
00b5                    PWMPER1:        equ REGBASE+$b5 ;pwm channel 1 period
00b6                    PWMPER2:        equ REGBASE+$b6 ;pwm channel 2 period
00b7                    PWMPER3:        equ REGBASE+$b7 ;pwm channel 3 period
00b8                    PWMPER4:        equ REGBASE+$b8 ;pwm channel 4 period
00b9                    PWMPER5:        equ REGBASE+$b9 ;pwm channel 5 period
00ba                    PWMPER6:        equ REGBASE+$ba ;pwm channel 6 period
00bb                    PWMPER7:        equ REGBASE+$bb ;pwm channel 7 period
00bc                    PWMDTY0:        equ REGBASE+$bc ;pwm channel 0 duty cycle
00bd                    PWMDTY1:        equ REGBASE+$bd ;pwm channel 1 duty cycle
00be                    PWMDTY2:        equ REGBASE+$be ;pwm channel 2 duty cycle
00bf                    PWMDTY3:        equ REGBASE+$bf ;pwm channel 3 duty cycle
00c0                    PWMDTY4:        equ REGBASE+$c0 ;pwm channel 4 duty cycle
00c1                    PWMDTY5:        equ REGBASE+$c1 ;pwm channel 5 duty cycle
00c2                    PWMDTY6:        equ REGBASE+$c2 ;pwm channel 6 duty cycle
00c3                    PWMDTY7:        equ REGBASE+$c3 ;pwm channel 7 duty cycle
00c4                    PWMSDN:         equ REGBASE+$c4 ;pwm shutdown register
                        
00c8                    SC0BDH:         equ REGBASE+$c8 ;sci 0 baud reg hi byte
00c9                    SC0BDL:         equ REGBASE+$c9 ;sci 0 baud reg lo byte
00ca                    SC0CR1:         equ REGBASE+$ca ;sci 0 control1 reg
00cb                    SC0CR2:         equ REGBASE+$cb ;sci 0 control2 reg
00cc                    SC0SR1:         equ REGBASE+$cc ;sci 0 status reg 1
00cd                    SC0SR2:         equ REGBASE+$cd ;sci 0 status reg 2
00ce                    SC0DRH:         equ REGBASE+$ce ;sci 0 data reg hi
00cf                    SC0DRL:         equ REGBASE+$cf ;sci 0 data reg lo
                        
00d0                    SC1BDH:         equ REGBASE+$d0 ;sci 1 baud reg hi byte
00d1                    SC1BDL:         equ REGBASE+$d1 ;sci 1 baud reg lo byte
00d2                    SC1CR1:         equ REGBASE+$d2 ;sci 1 control1 reg
00d3                    SC1CR2:         equ REGBASE+$d3 ;sci 1 control2 reg
00d4                    SC1SR1:         equ REGBASE+$d4 ;sci 1 status reg 1
00d5                    SC1SR2:         equ REGBASE+$d5 ;sci 1 status reg 2
00d6                    SC1DRH:         equ REGBASE+$d6 ;sci 1 data reg hi
00d7                    SC1DRL:         equ REGBASE+$d7 ;sci 1 data reg lo
                        
00d8                    SPI0CR1:        equ REGBASE+$d8 ;spi 0 control1 reg
00d9                    SPI0CR2:        equ REGBASE+$d9 ;spi 0 control2 reg
00da                    SPI0BR:         equ REGBASE+$da ;spi 0 baud reg
00db                    SPI0SR:         equ REGBASE+$db ;spi 0 status reg hi
00dd                    SP0DR:          equ REGBASE+$dd ;spi 0 data reg  FOR COMPATIBILITY
00dd                    SPI0DR:          equ REGBASE+$dd ;spi 0 data reg
                        
00e0                    IBAD:		equ REGBASE+$e0 ;i2c bus address register
00e1                    IBFD:		equ REGBASE+$e1 ;i2c bus frequency divider
00e2                    IBCR:		equ REGBASE+$e2 ;i2c bus control register
00e3                    IBSR:		equ REGBASE+$e3 ;i2c bus status register
00e4                    IBDR:		equ REGBASE+$e4 ;i2c bus message data register
                        
00e8                    DLCBCR1:	equ REGBASE+$e8 ;bdlc control regsiter 1
00e9                    DLCBSVR:	equ REGBASE+$e9 ;bdlc state vector register
00ea                    DLCBCR2:	equ REGBASE+$ea ;bdlc control register 2
00eb                    DLCBDR:		equ REGBASE+$eb ;bdlc data register
00ec                    DLCBARD:	equ REGBASE+$ec ;bdlc analog delay register
00ed                    DLCBRSR:	equ REGBASE+$ed ;bdlc rate select register
00ee                    DLCSCR:		equ REGBASE+$ee ;bdlc control register
00ef                    DLCBSTAT:	equ REGBASE+$ef ;bdlc status register
                        
00f0                    SPI1CR1:        equ REGBASE+$f0 ;spi 1 control1 reg
00f1                    SPI1CR2:        equ REGBASE+$f1 ;spi 1 control2 reg
00f2                    SPI1BR:         equ REGBASE+$f2 ;spi 1 baud reg
00f3                    SPI1SR:         equ REGBASE+$f3 ;spi 1 status reg hi
00f5                    SPI1DR:          equ REGBASE+$f5 ;spi 1 data reg
00f5                    SP1DR:          equ REGBASE+$f5 ;spi 1 data reg   FOR COMPATIBILITY
                        
00f8                    SPI2CR1:        equ REGBASE+$f8 ;spi 2 control1 reg
00f9                    SPI2CR2:        equ REGBASE+$f9 ;spi 2 control2 reg
00fa                    SPI2BR:         equ REGBASE+$fa ;spi 2 baud reg
00fb                    SPI2SR:         equ REGBASE+$fb ;spi 2 status reg hi
00fd                    SPI2DR:         equ REGBASE+$fd ;spi 2 data reg
00fd                    SP2DR:          equ REGBASE+$fd ;spi 2 data reg   FOR COMPATIBILITY
                        
0100                    FCLKDIV:	equ REGBASE+$100 ;flash clock divider
0101                    FSEC:		equ REGBASE+$101 ;flash security register
                        
0103                    FCNFG:		equ REGBASE+$103 ;flash configuration register
0104                    FPROT:		equ REGBASE+$104 ;flash protection register
0105                    FSTAT:		equ REGBASE+$105 ;flash status register
0106                    FCMD:		equ REGBASE+$106 ;flash command register
                        
0110                    ECLKDIV:	equ REGBASE+$110 ;eeprom clock divider
                        
0113                    ECNFG:		equ REGBASE+$113 ;eeprom configuration register
0114                    EPROT:		equ REGBASE+$114 ;eeprom protection register
0115                    ESTAT:		equ REGBASE+$115 ;eeprom status register
0116                    ECMD:		equ REGBASE+$116 ;eeprom command register
                        
0120                    ATD1CTL0:       equ REGBASE+$120 ;adc1 control 0 (reserved)
0121                    ATD1CTL1:       equ REGBASE+$121 ;adc1 control 1 (reserved)
0122                    ATD1CTL2:       equ REGBASE+$122 ;adc1 control 2
0123                    ATD1CTL3:       equ REGBASE+$123 ;adc1 control 3
0124                    ATD1CTL4:       equ REGBASE+$124 ;adc1 control 4
0125                    ATD1CTL5:       equ REGBASE+$125 ;adc1 control 5
0126                    ATD1STAT0:      equ REGBASE+$126 ;adc1 status register hi
012b                    ATD1STAT1:      equ REGBASE+$12b ;adc1 status register lo
0128                    ATD1TEST:       equ REGBASE+$128 ;adc1 test (reserved)
                        *atd1test       equ REGBASE+$129 ;
                        
012d                    ATDDIEN:	equ REGBASE+$12d ;adc1 input enable register
                        
012f                    PORTAD1:        equ REGBASE+$12f ;port adc1 = input only
0130                    ADR10H:         equ REGBASE+$130 ;adc1 result 0 register
0132                    ADR11H:         equ REGBASE+$132 ;adc1 result 1 register
0134                    ADR12H:         equ REGBASE+$134 ;adc1 result 2 register
0136                    ADR13H:         equ REGBASE+$136 ;adc1 result 3 register
0138                    ADR14H:         equ REGBASE+$138 ;adc1 result 4 register
013a                    ADR15H:         equ REGBASE+$13a ;adc1 result 5 register
013c                    ADR16H:         equ REGBASE+$13c ;adc1 result 6 register
013e                    ADR17H:         equ REGBASE+$13e ;adc1 result 7 register
                        
0140                    CAN0CTL0:	equ REGBASE+$140 ;can0 control register 0
0141                    CAN0CTL1:	equ REGBASE+$141 ;can0 control register 1
0142                    CAN0BTR0:	equ REGBASE+$142 ;can0 bus timing register 0
0143                    CAN0BTR1:	equ REGBASE+$143 ;can0 bus timing register 1
0144                    CAN0RFLG:	equ REGBASE+$144 ;can0 receiver flags
0145                    CAN0RIER:	equ REGBASE+$145 ;can0 receiver interrupt enables
0146                    CAN0TFLG:	equ REGBASE+$146 ;can0 transmit flags
0147                    CAN0TIER:	equ REGBASE+$147 ;can0 transmit interrupt enables
0148                    CAN0TARQ:	equ REGBASE+$148 ;can0 transmit message abort control
0149                    CAN0TAAK:	equ REGBASE+$149 ;can0 transmit message abort status
014a                    CAN0TBEL:	equ REGBASE+$14a ;can0 transmit buffer select
014b                    CAN0IDAC:	equ REGBASE+$14b ;can0 identfier acceptance control
                        
014e                    CAN0RERR:	equ REGBASE+$14e ;can0 receive error counter
014f                    CAN0TERR:	equ REGBASE+$14f ;can0 transmit error counter
0150                    CAN0IDA0:	equ REGBASE+$150 ;can0 identifier acceptance register 0
0151                    CAN0IDA1:	equ REGBASE+$151 ;can0 identifier acceptance register 1
0152                    CAN0IDA2:	equ REGBASE+$152 ;can0 identifier acceptance register 2
0153                    CAN0IDA3:	equ REGBASE+$153 ;can0 identifier acceptance register 3
0154                    CAN0IDM0:	equ REGBASE+$154 ;can0 identifier mask register 0
0155                    CAN0IDM1:	equ REGBASE+$155 ;can0 identifier mask register 1
0156                    CAN0IDM2:	equ REGBASE+$156 ;can0 identifier mask register 2
0157                    CAN0IDM3:	equ REGBASE+$157 ;can0 identifier mask register 3
0158                    CAN0IDA4:	equ REGBASE+$158 ;can0 identifier acceptance register 4
0159                    CAN0IDA5:	equ REGBASE+$159 ;can0 identifier acceptance register 5
015a                    CAN0IDA6:	equ REGBASE+$15a ;can0 identifier acceptance register 6
015b                    CAN0IDA7:	equ REGBASE+$15b ;can0 identifier acceptance register 7
015c                    CAN0IDM4:	equ REGBASE+$15c ;can0 identifier mask register 4
015d                    CAN0IDM5:	equ REGBASE+$15d ;can0 identifier mask register 5
015e                    CAN0IDM6:	equ REGBASE+$15e ;can0 identifier mask register 6
015f                    CAN0IDM7:	equ REGBASE+$15f ;can0 identifier mask register 7
0160                    CAN0RXFG:	equ REGBASE+$160 ;can0 rx foreground buffer thru +$16f
0170                    CAN0TXFG:	equ REGBASE+$170 ;can0 tx foreground buffer thru +$17f
                        
0180                    CAN1CTL0:	equ REGBASE+$180 ;can1 control register 0
0181                    CAN1CTL1:	equ REGBASE+$181 ;can1 control register 1
0182                    CAN1BTR0:	equ REGBASE+$182 ;can1 bus timing register 0
0183                    CAN1BTR1:	equ REGBASE+$183 ;can1 bus timing register 1
0184                    CAN1RFLG:	equ REGBASE+$184 ;can1 receiver flags
0185                    CAN1RIER:	equ REGBASE+$185 ;can1 receiver interrupt enables
0186                    CAN1TFLG:	equ REGBASE+$186 ;can1 transmit flags
0187                    CAN1TIER:	equ REGBASE+$187 ;can1 transmit interrupt enables
0188                    CAN1TARQ:	equ REGBASE+$188 ;can1 transmit message abort control
0189                    CAN1TAAK:	equ REGBASE+$189 ;can1 transmit message abort status
018a                    CAN1TBEL:	equ REGBASE+$18a ;can1 transmit buffer select
018b                    CAN1IDAC:	equ REGBASE+$18b ;can1 identfier acceptance control
                        
018e                    CAN1RERR:	equ REGBASE+$18e ;can1 receive error counter
018f                    CAN1TERR:	equ REGBASE+$18f ;can1 transmit error counter
0190                    CAN1IDA0:	equ REGBASE+$190 ;can1 identifier acceptance register 0
0191                    CAN1IDA1:	equ REGBASE+$191 ;can1 identifier acceptance register 1
0192                    CAN1IDA2:	equ REGBASE+$192 ;can1 identifier acceptance register 2
0193                    CAN1IDA3:	equ REGBASE+$193 ;can1 identifier acceptance register 3
0194                    CAN1IDM0:	equ REGBASE+$194 ;can1 identifier mask register 0
0195                    CAN1IDM1:	equ REGBASE+$195 ;can1 identifier mask register 1
0196                    CAN1IDM2:	equ REGBASE+$196 ;can1 identifier mask register 2
0197                    CAN1IDM3:	equ REGBASE+$197 ;can1 identifier mask register 3
0198                    CAN1IDA4:	equ REGBASE+$198 ;can1 identifier acceptance register 4
0199                    CAN1IDA5:	equ REGBASE+$199 ;can1 identifier acceptance register 5
019a                    CAN1IDA6:	equ REGBASE+$19a ;can1 identifier acceptance register 6
019b                    CAN1IDA7:	equ REGBASE+$19b ;can1 identifier acceptance register 7
019c                    CAN1IDM4:	equ REGBASE+$19c ;can1 identifier mask register 4
019d                    CAN1IDM5:	equ REGBASE+$19d ;can1 identifier mask register 5
019e                    CAN1IDM6:	equ REGBASE+$19e ;can1 identifier mask register 6
019f                    CAN1IDM7:	equ REGBASE+$19f ;can1 identifier mask register 7
01a0                    CAN1RXFG:	equ REGBASE+$1a0 ;can1 rx foreground buffer thru +$1af
01b0                    CAN1TXFG:	equ REGBASE+$1b0 ;can1 tx foreground buffer thru +$1bf
                        
01c0                    CAN2CTL0:	equ REGBASE+$1c0 ;can2 control register 0
01c1                    CAN2CTL1:	equ REGBASE+$1c1 ;can2 control register 1
01c2                    CAN2BTR0:	equ REGBASE+$1c2 ;can2 bus timing register 0
01c3                    CAN2BTR1:	equ REGBASE+$1c3 ;can2 bus timing register 1
01c4                    CAN2RFLG:	equ REGBASE+$1c4 ;can2 receiver flags
01c5                    CAN2RIER:	equ REGBASE+$1c5 ;can2 receiver interrupt enables
01c6                    CAN2TFLG:	equ REGBASE+$1c6 ;can2 transmit flags
01c7                    CAN2TIER:	equ REGBASE+$1c7 ;can2 transmit interrupt enables
01c8                    CAN2TARQ:	equ REGBASE+$1c8 ;can2 transmit message abort control
01c9                    CAN2TAAK:	equ REGBASE+$1c9 ;can2 transmit message abort status
01ca                    CAN2TBEL:	equ REGBASE+$1ca ;can2 transmit buffer select
01cb                    CAN2IDAC:	equ REGBASE+$1cb ;can2 identfier acceptance control
                        
01ce                    CAN2RERR:	equ REGBASE+$1ce ;can2 receive error counter
01cf                    CAN2TERR:	equ REGBASE+$1cf ;can2 transmit error counter
01d0                    CAN2IDA0:	equ REGBASE+$1d0 ;can2 identifier acceptance register 0
01d1                    CAN2IDA1:	equ REGBASE+$1d1 ;can2 identifier acceptance register 1
01d2                    CAN2IDA2:	equ REGBASE+$1d2 ;can2 identifier acceptance register 2
01d3                    CAN2IDA3:	equ REGBASE+$1d3 ;can2 identifier acceptance register 3
01d4                    CAN2IDM0:	equ REGBASE+$1d4 ;can2 identifier mask register 0
01d5                    CAN2IDM1:	equ REGBASE+$1d5 ;can2 identifier mask register 1
01d6                    CAN2IDM2:	equ REGBASE+$1d6 ;can2 identifier mask register 2
01d7                    CAN2IDM3:	equ REGBASE+$1d7 ;can2 identifier mask register 3
01d8                    CAN2IDA4:	equ REGBASE+$1d8 ;can2 identifier acceptance register 4
01d9                    CAN2IDA5:	equ REGBASE+$1d9 ;can2 identifier acceptance register 5
01da                    CAN2IDA6:	equ REGBASE+$1da ;can2 identifier acceptance register 6
01db                    CAN2IDA7:	equ REGBASE+$1db ;can2 identifier acceptance register 7
01dc                    CAN2IDM4:	equ REGBASE+$1dc ;can2 identifier mask register 4
01dd                    CAN2IDM5:	equ REGBASE+$1dd ;can2 identifier mask register 5
01de                    CAN2IDM6:	equ REGBASE+$1de ;can2 identifier mask register 6
01df                    CAN2IDM7:	equ REGBASE+$1df ;can2 identifier mask register 7
01e0                    CAN2RXFG:	equ REGBASE+$1e0 ;can2 rx foreground buffer thru +$1ef
01f0                    CAN2TXFG:	equ REGBASE+$1f0 ;can2 tx foreground buffer thru +$1ff
                        
0200                    CAN3CTL0:	equ REGBASE+$200 ;can3 control register 0
0201                    CAN3CTL1:	equ REGBASE+$201 ;can3 control register 1
0202                    CAN3BTR0:	equ REGBASE+$202 ;can3 bus timing register 0
0203                    CAN3BTR1:	equ REGBASE+$203 ;can3 bus timing register 1
0204                    CAN3RFLG:	equ REGBASE+$204 ;can3 receiver flags
0205                    CAN3RIER:	equ REGBASE+$205 ;can3 receiver interrupt enables
0206                    CAN3TFLG:	equ REGBASE+$206 ;can3 transmit flags
0207                    CAN3TIER:	equ REGBASE+$207 ;can3 transmit interrupt enables
0208                    CAN3TARQ:	equ REGBASE+$208 ;can3 transmit message abort control
0209                    CAN3TAAK:	equ REGBASE+$209 ;can3 transmit message abort status
020a                    CAN3TBEL:	equ REGBASE+$20a ;can3 transmit buffer select
020b                    CAN3IDAC:	equ REGBASE+$20b ;can3 identfier acceptance control
                        
020e                    CAN3RERR:	equ REGBASE+$20e ;can3 receive error counter
020f                    CAN3TERR:	equ REGBASE+$20f ;can3 transmit error counter
0210                    CAN3IDA0:	equ REGBASE+$210 ;can3 identifier acceptance register 0
0211                    CAN3IDA1:	equ REGBASE+$211 ;can3 identifier acceptance register 1
0212                    CAN3IDA2:	equ REGBASE+$212 ;can3 identifier acceptance register 2
0213                    CAN3IDA3:	equ REGBASE+$213 ;can3 identifier acceptance register 3
0214                    CAN3IDM0:	equ REGBASE+$214 ;can3 identifier mask register 0
0215                    CAN3IDM1:	equ REGBASE+$215 ;can3 identifier mask register 1
0216                    CAN3IDM2:	equ REGBASE+$216 ;can3 identifier mask register 2
0217                    CAN3IDM3:	equ REGBASE+$217 ;can3 identifier mask register 3
0218                    CAN3IDA4:	equ REGBASE+$218 ;can3 identifier acceptance register 4
0219                    CAN3IDA5:	equ REGBASE+$219 ;can3 identifier acceptance register 5
021a                    CAN3IDA6:	equ REGBASE+$21a ;can3 identifier acceptance register 6
021b                    CAN3IDA7:	equ REGBASE+$21b ;can3 identifier acceptance register 7
021c                    CAN3IDM4:	equ REGBASE+$21c ;can3 identifier mask register 4
021d                    CAN3IDM5:	equ REGBASE+$21d ;can3 identifier mask register 5
021e                    CAN3IDM6:	equ REGBASE+$21e ;can3 identifier mask register 6
021f                    CAN3IDM7:	equ REGBASE+$21f ;can3 identifier mask register 7
0220                    CAN3RXFG:	equ REGBASE+$220 ;can3 rx foreground buffer thru +$22f
0230                    CAN3TXFG:	equ REGBASE+$230 ;can3 tx foreground buffer thru +$23f
                        
0240                    PTT:		equ REGBASE+$240 ;portt data register
0241                    PTIT:		equ REGBASE+$241 ;portt input register
0242                    DDRT:		equ REGBASE+$242 ;portt direction register
0243                    RDRT:		equ REGBASE+$243 ;portt reduced drive register
0244                    PERT:		equ REGBASE+$244 ;portt pull device enable
0245                    PPST:		equ REGBASE+$245 ;portt pull polarity select
                        
0248                    PTS:		equ REGBASE+$248 ;ports data register
0249                    PTIS:		equ REGBASE+$249 ;ports input register
024a                    DDRS:		equ REGBASE+$24a ;ports direction register
024b                    RDRS:		equ REGBASE+$24b ;ports reduced drive register
024c                    PERS:		equ REGBASE+$24c ;ports pull device enable
024d                    PPSS:		equ REGBASE+$24d ;ports pull polarity select
024e                    WOMS:		equ REGBASE+$24e ;ports wired or mode register
                        
0250                    PTM:		equ REGBASE+$250 ;portm data register
0251                    PTIM:		equ REGBASE+$251 ;portm input register
0252                    DDRM:		equ REGBASE+$252 ;portm direction register
0253                    RDRM:		equ REGBASE+$253 ;portm reduced drive register
0254                    PERM:		equ REGBASE+$254 ;portm pull device enable
0255                    PPSM:		equ REGBASE+$255 ;portm pull polarity select
0256                    WOMM:		equ REGBASE+$256 ;portm wired or mode register
0257                    MODRR:		equ REGBASE+$257 ;portm module routing register
                        
0258                    PTP:		equ REGBASE+$258 ;portp data register
0259                    PTIP:		equ REGBASE+$259 ;portp input register
025a                    DDRP:		equ REGBASE+$25a ;portp direction register
025b                    RDRP:		equ REGBASE+$25b ;portp reduced drive register
025c                    PERP:		equ REGBASE+$25c ;portp pull device enable
025d                    PPSP:		equ REGBASE+$25d ;portp pull polarity select
025e                    PIEP:		equ REGBASE+$25e ;portp interrupt enable register
025f                    PIFP:		equ REGBASE+$25f ;portp interrupt flag register
                        
0260                    PTH:		equ REGBASE+$260 ;porth data register
0261                    PTIH:		equ REGBASE+$261 ;porth input register
0262                    DDRH:		equ REGBASE+$262 ;porth direction register
0263                    RDRH:		equ REGBASE+$263 ;porth reduced drive register
0264                    PERH:		equ REGBASE+$264 ;porth pull device enable
0265                    PPSH:		equ REGBASE+$265 ;porth pull polarity select
0266                    PIEH:		equ REGBASE+$266 ;porth interrupt enable register
0267                    PIFH:		equ REGBASE+$267 ;porth interrupt flag register
                        
0268                    PTJ:		equ REGBASE+$268 ;portj data register
0269                    PTIJ:		equ REGBASE+$269 ;portj input register
026a                    DDRJ:		equ REGBASE+$26a ;portj direction register
026b                    RDRJ:		equ REGBASE+$26b ;portj reduced drive register
026c                    PERJ:		equ REGBASE+$26c ;portj pull device enable
026d                    PPSJ:		equ REGBASE+$26d ;portj pull polarity select
026e                    PIEJ:		equ REGBASE+$26e ;portj interrupt enable register
026f                    PIFJ:		equ REGBASE+$26f ;portj interrupt flag register
                        
0280                    CAN4CTL0:	equ REGBASE+$280 ;can4 control register 0
0281                    CAN4CTL1:	equ REGBASE+$281 ;can4 control register 1
0282                    CAN4BTR0:	equ REGBASE+$282 ;can4 bus timing register 0
0283                    CAN4BTR1:	equ REGBASE+$283 ;can4 bus timing register 1
0284                    CAN4RFLG:	equ REGBASE+$284 ;can4 receiver flags
0285                    CAN4RIER:	equ REGBASE+$285 ;can4 receiver interrupt enables
0286                    CAN4TFLG:	equ REGBASE+$286 ;can4 transmit flags
0287                    CAN4TIER:	equ REGBASE+$287 ;can4 transmit interrupt enables
0288                    CAN4TARQ:	equ REGBASE+$288 ;can4 transmit message abort control
0289                    CAN4TAAK:	equ REGBASE+$289 ;can4 transmit message abort status
028a                    CAN4TBEL:	equ REGBASE+$28a ;can4 transmit buffer select
028b                    CAN4IDAC:	equ REGBASE+$28b ;can4 identfier acceptance control
                        
028e                    CAN4RERR:	equ REGBASE+$28e ;can4 receive error counter
028f                    CAN4TERR:	equ REGBASE+$28f ;can4 transmit error counter
0290                    CAN4IDA0:	equ REGBASE+$290 ;can4 identifier acceptance register 0
0291                    CAN4IDA1:	equ REGBASE+$291 ;can4 identifier acceptance register 1
0292                    CAN4IDA2:	equ REGBASE+$292 ;can4 identifier acceptance register 2
0293                    CAN4IDA3:	equ REGBASE+$293 ;can4 identifier acceptance register 3
0294                    CAN4IDM0:	equ REGBASE+$294 ;can4 identifier mask register 0
0295                    CAN4IDM1:	equ REGBASE+$295 ;can4 identifier mask register 1
0296                    CAN4IDM2:	equ REGBASE+$296 ;can4 identifier mask register 2
0297                    CAN4IDM3:	equ REGBASE+$297 ;can4 identifier mask register 3
0298                    CAN4IDA4:	equ REGBASE+$298 ;can4 identifier acceptance register 4
0299                    CAN4IDA5:	equ REGBASE+$299 ;can4 identifier acceptance register 5
029a                    CAN4IDA6:	equ REGBASE+$29a ;can4 identifier acceptance register 6
029b                    CAN4IDA7:	equ REGBASE+$29b ;can4 identifier acceptance register 7
029c                    CAN4IDM4:	equ REGBASE+$29c ;can4 identifier mask register 4
029d                    CAN4IDM5:	equ REGBASE+$29d ;can4 identifier mask register 5
029e                    CAN4IDM6:	equ REGBASE+$29e ;can4 identifier mask register 6
029f                    CAN4IDM7:	equ REGBASE+$29f ;can4 identifier mask register 7
02a0                    CAN4RXFG:	equ REGBASE+$2a0 ;can4 rx foreground buffer thru +$2af
02b0                    CAN4TXFG:	equ REGBASE+$2b0 ;can4 tx foreground buffer thru +$2bf
                        
                        * end registers
                        
1000                            org     DATASTART
                        ; Variables for motor control
1000                    running:        ds      1       ; 1 -- motor on, 0 -- motor off
1001                    reverse:        ds      1       ; 1 -- forward, 0 -- reverse
1002                    speed:          ds      1       ; 0 to 9 for speed
                        
                        ; Variables and equates for motor interface
0001                    EN12:           equ     %00000001  ; Port P Enable MOT1,2
0002                    EN34:           equ     %00000010  ; Port P Enable MOT3,4
0001                    MOT1:           equ     %00000001  ; Port B MOT1
0002                    MOT2:           equ     %00000010  ; Port B MOT2
0004                    MOT3:           equ     %00000100  ; Port B MOT3
0008                    MOT4:           equ     %00001000  ; PORT B MOT4
                        #ifdef STEPPER_MOTOR
1003                    phase:          ds      1       ; phase value, 0,1,2, or 3
1004                    fraction:       ds      2       ; fraction of time until phase change
                        #endif
                        
                        ; Equates and Variables for LCD interface
0001                    REG_SEL:        equ     %00000001       ; 0=reg, 1=data (LCD)
0002                    ENABLE:         equ     %00000010
0020                    LCDBUFLEN:      equ     32              ; Size of LCD output buffer
1006                    lcdbuf:         ds   LCDBUFLEN  ; LCD output buffer
1026                    lcdbufin:       ds   2          ; Pointer to buffer input
1028                    lcdbufout:      ds   2          ; pointer to buffer output
102a                    lcdstate:       ds   2          ; LCD state machine state
102c                    lcddelay:       ds   1          ; LCD state machine delay counter
                        
                        ; Variables for keyboard interface
102d                    keybuf:         ds      1
102e                    temp:           ds      1
102f                    tempcnt:        ds      1
1030                    lastval:        ds      1
1031                    debcnt:         ds      1
                        
2000                            org     PRSTART
                        ;
                        ; Start of program -- Initialization
                        ;
2000                    start:  
                                ; Initialize stack pointer
2000 cf 20 00                   lds     #DATAEND
                        
                                ; Initialize motor contol
2003 79 10 00                   clr     running
2006 79 10 01                   clr     reverse
2009 79 10 02                   clr     speed
                        
                                ; Initialize motor interface
200c 79 02 58                   clr     PTP     ; make sure motor interface is disabled
200f 1c 02 5a 03                bset    DDRP #EN12+EN34
2013 1c 02 6a 02                bset    DDRJ #2         ; Enable LEDs for pretty display
2017 79 02 68                   clr     PTJ
                        #ifdef STEPPER_MOTOR
201a 79 00 01                   clr     PORTB
201d 4c 03 cf                   bset    DDRB #MOT1+MOT2+MOT3+MOT4+$c0 ; last for pretty display
2020 4c 40 01                   bset    TIOS #1         ; We will use timer channel 0
2023 4c 46 90                   bset    TSCR1 #$90      ; TEN=1, TFFCA=1
2026 4c 4c 01                   bset    TIE #1          ; C0I=1
2029 18 03 22 e3 3e 6e          movw    #TC0ISR UserTimerCh0    ; Initialize vector
202f 79 10 03                   clr     phase
2032 18 03 00 00 10 04          movw    #0 fraction
                        
                        #endif
                        #ifdef DC_MOTOR
                                bset    DDRB #MOT1+MOT2
                                movb    #MOT1 PORTB     ; Initialize to forward direction
                                ; Initialize PWM channel 0
                                ; we want PWM clock period to be 50us/9
                                ; to run at 20kHz so we can't hear the motor windings
                                ; This means a divisor of 133.
                                movb    #66 PWMSCLA     ; use clock SA
                                bset    PWME #$01       ; PWME0=1
                                bset    PWMPOL #$01     ; PPOL0=1
                                bset    PWMCLK #$01     ; PCLK0=1
                                movb    #9 PWMPER0
                        ;       movb    #0 PWMDTY0      ; duty cycle = 0%
                        #endif
                                ; Initilize LCD driver data RAM
2038 18 03 10 06 10 26          movw    #lcdbuf lcdbufin
203e 18 03 10 06 10 28          movw    #lcdbuf lcdbufout
2044 18 03 22 5c 10 2a          movw    #LCDCLEARDELAY lcdstate   ; 15 msec delay before using LCD
204a 18 0b 0e 10 2c             movb    #14 lcddelay              ; gives 15 msec delay (one more than value)
                        
                                ; Initialize microcontroller interface to LCD
204f 18 0b ff 00 33             movb    #$ff,DDRK       ; port K = output
2054 79 00 32                   clr     PORTK
                        
                                ; Initialize RTI
2057 18 03 21 e2 3e 70          movw    #rtiisr,UserRTI ; initialize the RTI vector
205d 18 0b 17 00 3b             movb    #RTI_DIVIDER,RTICTL   ; RTI divider for 1 mSec
2062 4c 38 80                   bset    CRGINT,#$80     ; enable RTI interrupts
                        
                                ; Initialize microcontroller interface to keypad
2065 18 0b 0f 00 02             movb    #$0f,ddra       ; pa0 to pa3 are outputs while 4 to 7 are inputs
206a 4c 0c 01                   bset    PUCR #1         ; enable pullup for keypad
                        
                                ; Initialize keypad variables
206d 18 0b ff 10 2d             movb    #(-1)&$ff,keybuf      ; no key
2072 86 f7                      ldaa    #$f7            ; template for msb of output being low
2074 5a 00                      staa    porta
2076 7a 10 2e                   staa    temp            ; save it
2079 7a 10 30                   staa    lastval
207c 18 0b 03 10 2f             movb    #3,tempcnt      ; counter
2081 18 0b 0a 10 31             movb    #10,debcnt      ; poll every 10mSec for good debouncing
                        
                                ; Enable Interrupts and initialize LCD display hardware
2086 10 ef                      cli
2088 16 21 bb                   jsr     lcd_ini
208b 06 21 03                   jmp     help            ; start with HELP
                        ;
                        ; Idle Process -- read and process keystrokes
                        ;
208e 16 21 68           loop:   jsr     getkey          ; Check out a keystroke
2091 81 09                      cmpa    #9              ; 0 - 9 are numeric
2093 22 0a                      bhi     not_numeric
2095 7a 10 02                   staa    speed           ; save speed value
2098 18 0b 01 10 00             movb    #1,running
209d 20 31                      bra     lcd_update
209f                    not_numeric:
209f 81 1f                      cmpa    #$1f            ; * key is forward
20a1 26 0d                      bne     not_forward
20a3 79 10 02                   clr     speed           ; Don't change direction if running
20a6 79 10 01                   clr     reverse         ; set direction to forward
20a9 18 0b 01 10 00             movb    #1,running
20ae 20 20                      bra     lcd_update
20b0                    not_forward:
20b0 81 11                      cmpa    #$11            ; # key is backwards
20b2 26 0f                      bne     not_backwards
20b4 79 10 02                   clr     speed           ; don't change direction if running
20b7 18 0b 01 10 01             movb    #1,reverse      ; set direction to reverse
20bc 18 0b 01 10 00             movb    #1,running
20c1 20 0d                      bra     lcd_update
20c3                    not_backwards:
20c3 81 0d                      cmpa    #$d             ; lower right key is motor off
20c5 26 3c                      bne     help            ; other keys not used -- go to help
20c7 79 10 00                   clr     running         ; clear everything when off
20ca 79 10 02                   clr     speed
20cd 79 10 01                   clr     reverse
                                
                                ; update the LCD display
20d0                    lcd_update:
20d0 16 21 a0                   jsr     lcd_line1
20d3 f7 10 00                   tst     running         ; are we off?
20d6 26 08                      bne     we_are_running
20d8 ce 23 71                   ldx     #omsg
20db 16 21 b2                   jsr     msg_out
20de 20 20                      bra     finish_LCD
20e0                    we_are_running:
20e0 f7 10 01                   tst     reverse         ; Are we in reverse?
20e3 26 08                      bne     we_are_backing
20e5 ce 23 5e                   ldx     #fmsg
20e8 16 21 b2                   jsr     msg_out
20eb 20 06                      bra     we_are_moving
20ed                    we_are_backing:
20ed ce 23 67                   ldx     #bmsg
20f0 16 21 b2                   jsr     msg_out
20f3                    we_are_moving:
20f3 b6 10 02                   ldaa    speed           ; Display speed value
20f6 8b 30                      adda    #'0             ; convert to ASCII character
20f8 16 21 76                   jsr     putlcd
20fb 86 20                      ldaa    #' 
20fd 16 21 76                   jsr     putlcd
2100                    finish_LCD:
                        
                        #ifdef DC_MOTOR
                                ; update the DC Motor driver settings
                                ldaa    #MOT1           ; forward
                                tst     reverse
                                beq     not_reverse
                                ldaa    #MOT2           ; reverse
                        not_reverse:
                                staa    PORTB
                                movb    speed PWMDTY0   ; If we aren't running, speed is 0
                        #endif
                        
2100 06 20 8e                   jmp     loop
                        
                        ; Display instructions
2103 16 21 a0           help:   jsr     lcd_line1
2106 ce 23 7c                   ldx     #imsg
2109 16 21 b2                   jsr     msg_out
210c 16 21 a9           help2:  jsr     lcd_line2
210f ce 23 8d                   ldx     #ins1
2112 16 21 b2                   jsr     msg_out
2115 16 21 ce                   jsr     long_delay
2118 f7 10 2d                   tst     keybuf                  ; finish if key hit
211b 2c 2e                      bge     help3
211d 16 21 a9                   jsr     lcd_line2
2120 ce 23 9e                   ldx     #ins2
2123 16 21 b2                   jsr     msg_out
2126 16 21 ce                   jsr     long_delay
2129 f7 10 2d                   tst     keybuf                  ; finish if key hit
212c 2c 1d                      bge     help3
212e 16 21 a9                   jsr     lcd_line2
2131 ce 23 af                   ldx     #ins3
2134 16 21 b2                   jsr     msg_out
2137 16 21 ce                   jsr     long_delay
213a f7 10 2d                   tst     keybuf                  ; finish if key hit
213d 2c 0c                      bge     help3
213f 16 21 a9                   jsr     lcd_line2
2142 ce 23 c0                   ldx     #ins4
2145 16 21 b2                   jsr     msg_out
2148 16 21 ce                   jsr     long_delay
214b 16 21 a9           help3:  jsr     lcd_line2               ; last line tells how to get help
214e ce 23 d1                   ldx     #ins5
2151 16 21 b2                   jsr     msg_out
2154 16 21 ce                   jsr     long_delay
2157 f7 10 2d                   tst     keybuf                  ; key hit?
215a 2d b0                      blt     help2
215c 16 21 a0                   jsr     lcd_line1
215f ce 23 e2                   ldx     #insc
2162 16 21 b2                   jsr     msg_out
2165 06 20 d0                   jmp     lcd_update              ; update display and process key
                        ;
                        ; Subroutines used for keypad and LCD access
                        ;
2168                    getkey: ; Get character from keypad and place in accumulator A
                                ; If none available, wait.
2168 b6 10 2d                   ldaa    keybuf
216b 2c 03                      bge     gotone          ; branch if key available
216d 3e                         wai                     ; wait if not
216e 20 f8                      bra     getkey          ; then try again
2170 18 0b ff 10 2d     gotone: movb    #-1,keybuf      ; mark buffer as empty
2175 3d                         rts
                        
2176                    putlcd: ; Write character in register A to LCD
2176 34                         pshx
2177 b7 45                      tfr     d x             ; save A:B in X, X on stack
2179 fc 10 26           putlcd2: ldd     lcdbufin       ; calculate # characters in buffer
217c b3 10 28                   subd    lcdbufout
217f 2a 03                      bpl     putlcd3
2181 c3 00 20                   addd    #LCDBUFLEN      ; If negative, adjust (circular arithmetic)
2184 8c 00 1f           putlcd3: cpd     #LCDBUFLEN-1   ; Is there room?
2187 26 03                      bne     putlcd4
2189 3e                         wai                     ; no room -- wait and try again 
218a 20 ed                      bra     putlcd2
218c b7 54              putlcd4: tfr     x d            ; a has character 
218e fe 10 26                   ldx     lcdbufin        ; get bufin again
2191 6a 30                      staa    1,x+            ; store character, increment buffer position
2193 8e 10 26                   cpx     #lcdbuf+LCDBUFLEN ; check for wrap
2196 26 03                      bne     putlcd5         ; not needed?
2198 ce 10 06                   ldx     #lcdbuf         ; wrap to start
219b 7e 10 26           putlcd5: stx    lcdbufin        ; save new bufin value
219e 30                         pulx
219f 3d                         rts
                        
21a0                    lcd_line1:      ; Position cursor at start of first line
21a0 86 ff                      ldaa    #$ff                    ; indicate instruction
21a2 07 d2                      bsr     putlcd
21a4 86 80                      ldaa    #$80                    ; starting address for the line1
21a6 07 ce                      bsr     putlcd
21a8 3d                         rts
                        
21a9                    lcd_line2:    ; position cursor at start of second line
21a9 86 ff                     ldaa    #$ff                    ; indicate instruction
21ab 07 c9                     bsr     putlcd
21ad 86 c0                     ldaa    #$C0                    ; starting address for the line2
21af 07 c5                     bsr     putlcd
21b1 3d                        rts
                        
21b2                    msg_out: ; Write out 0 terminated string at X to LCD
21b2 a6 30                      ldaa    1,x+
21b4 27 04                      beq     msg_end
21b6 07 be                      bsr     putlcd
21b8 20 f8                      bra     msg_out
21ba 3d                 msg_end: rts
                        
                        ; Initialize the LCD display module. All registers preserved
21bb                    lcd_ini:
21bb ce 23 58                   ldx     #inidsp
21be c6 06                      ldab    #6
21c0                    lcd_ini_loop:
21c0 86 ff                      ldaa    #$ff            ; $ff means following byte is command
21c2 16 21 76                   jsr     putlcd
21c5 a6 30                      ldaa    1,X+
21c7 16 21 76                   jsr     putlcd
21ca 04 31 f3                   dbne    b lcd_ini_loop
21cd 3d                         rts
                        
                        ; Long Delay
21ce                    long_delay: ; about two seconds
21ce 34                         pshx
21cf 3b                         pshd
21d0 ce 00 00                   ldx     #0
21d3 c7                 ld1:    clrb
21d4 04 31 fd           ld2:    dbne    b,ld2           ; 32 us delay
21d7 f7 10 2d                   tst     keybuf          ; cancel delay if key hit
21da 2c 03                      bge     ld3
21dc 04 35 f4                   dbne    x,ld1
21df 3a                 ld3:    puld
21e0 30                         pulx
21e1 3d                         rts
                        
21e2                    rtiisr: ; RTI Interrupt Service Routine
21e2 4c 37 80                   bset    CRGFLG,#$80     ; clear RTI interrupt flag
21e5 10 ef                      cli                     ; allow other interrupts to occur 
                                ;first -- handle the keyboard
21e7 73 10 31                   dec     debcnt          ; debcnt is counter for debouncing
21ea 26 45                      bne     lcdgo           ; don't do a thing 9 of 10 times ("low pass filter")
21ec 18 0b 0a 10 31             movb    #10,debcnt
21f1 96 00                      ldaa    PORTA           ; check keyboard
21f3 b1 10 30                   cmpa    lastval
21f6 27 1b                      beq     samelast        ; might mean to go to next row
21f8 7a 10 30                   staa    lastval
21fb 84 f0                      anda    #$f0            ; get only upper bits
21fd 44                         lsra
21fe 44                         lsra
21ff bb 10 2f                   adda    tempcnt         ; table index
2202 81 1c                      cmpa    #28             ; values less than 28 are invalid
2204 2d 2b                      blt     lcdgo
2206 b7 05                      tfr     a,x
2208 a6 e2 23 d7                ldaa    valtbl-28,x     ; get value
220c 2b 23                      bmi     lcdgo           ; no value so do nothing
220e 7a 10 2d                   staa    keybuf          ; represents next keystroke!
2211 20 1e                      bra     lcdgo
2213                    samelast:       ; if no depression, then go to next row for next interrupt
2213 84 f0                      anda    #$f0
2215 81 f0                      cmpa    #$F0            ; any depression?
2217 26 18                      bne     lcdgo           ; then do nothing for now
2219 b6 10 2e                   ldaa    temp
221c 47                         asra                    ; shift mask
221d 73 10 2f                   dec     tempcnt
2220 2c 07                      bge     nowrap
2222 18 0b 03 10 2f             movb    #3,tempcnt
2227 86 f7                      ldaa    #$f7            ; reset mask
2229 7a 10 2e           nowrap: staa    temp
222c 7a 10 30                   staa    lastval
222f 5a 00                      staa    PORTA
                        
                                ; Now handle the LCD driver
2231                    lcdgo:
2231 fe 10 2a                   ldx     lcdstate        ; go to current state
2234 05 00                      jmp     0,x
                        
2236                    LCDIDLE: ; Wait for next character
2236 fe 10 28                   ldx     lcdbufout
2239 be 10 26                   cpx     lcdbufin
223c 27 1d                      beq     lcdfin
223e a6 30                      ldaa    1,x+ 
2240 8e 10 26                   cpx     #lcdbuf+LCDBUFLEN
2243 26 03                      bne     lcdin2
2245 ce 10 06                   ldx     #lcdbuf
2248 7e 10 28           lcdin2: stx     lcdbufout
224b 81 ff                      cmpa    #(-1)&$ff
224d 27 2c                      beq     iscmd
224f 36                         psha            ; save temporarily
2250 84 f0                      anda   #$f0                     ; mask out 4 low bits.           
2252 44                         lsra
2253 44                         lsra                            ; 4 MSB bits go to pk2-pk5                              
2254 07 7b                      bsr     lcdnibble
2256 32                         pula
2257 48                         lsla                            ; move low bits over.
2258 48                         lsla
2259 07 76                      bsr     lcdnibble
225b 0b                 lcdfin: rti                             ; done with interrupt routine
                        
225c                    LCDCLEARDELAY: ; waiting on clear delay
225c 73 10 2c                   dec     lcddelay
225f 26 fa                      bne     lcdfin
2261 18 03 22 36 10 2a          movw    #LCDIDLE lcdstate
2267 0b                         rti
                        
2268                    LCDRESETDELAY: ; waiting on reset delay
2268 73 10 2c                   dec     lcddelay
226b 26 ee                      bne     lcdfin
226d 86 0c                      ldaa    #$0c                    ; reset lower nibble shifted left
226f 07 60                      bsr     lcdnibble
2271 4c 32 01                   bset    PORTK,#REG_SEL          ; select data
2274 18 03 22 36 10 2a          movw    #LCDIDLE lcdstate
227a 0b                         rti
                        
227b 18 03 22 81 10 2a  iscmd:  movw    #LCDCMD lcdstate
                        ;       bra     LCDCMD
2281                    LCDCMD:   ; Wait for command
2281 fe 10 28                   ldx     lcdbufout
2284 be 10 26                   cpx     lcdbufin
2287 27 d2                      beq     lcdfin
2289 a6 30                      ldaa    1,x+ 
228b 8e 10 26                   cpx     #lcdbuf+LCDBUFLEN
228e 26 03                      bne     lcdcin2
2290 ce 10 06                   ldx     #lcdbuf
2293 7e 10 28           lcdcin2: stx    lcdbufout
2296 36                         psha                            ; save the command
2297 4d 32 01                   bclr    PORTK,#REG_SEL          ; select instruction
229a 84 f0                      anda   #$f0                     ; mask out 4 low bits.           
229c 44                         lsra
229d 44                         lsra                            ; 4 MSB bits go to pk2-pk5                              
229e 07 31                      bsr     lcdnibble
22a0 32                         pula
22a1 81 33                      cmpa    #$33                    ; Reset requires a 5msec delay
22a3 27 14                      beq     lcdreset
22a5 36                         psha
22a6 48                         lsla                            ; move low bits over.
22a7 48                         lsla
22a8 07 27                      bsr     lcdnibble
22aa 4c 32 01                   bset    PORTK,#REG_SEL  ; select data
22ad 32                         pula
22ae 81 03                      cmpa    #$03                    ; clear requires 5 msec delay
22b0 23 13                      bls     lcdclear
22b2 18 03 22 36 10 2a          movw    #LCDIDLE lcdstate
22b8 0b                         rti
22b9 18 03 22 68 10 2a  lcdreset: movw #LCDRESETDELAY lcdstate   ; must delay before second part
22bf 18 0b 05 10 2c             movb    #5 lcddelay             ; gives 5 msec delay
22c4 0b                         rti
22c5 18 03 22 5c 10 2a  lcdclear: movw #LCDCLEARDELAY lcdstate   ; must delay before next command
22cb 18 0b 01 10 2c             movb    #1 lcddelay             ; gives 2 msec delay (one more than value)
22d0 0b                         rti
                        
                                ; Subroutine used by LCD driver -- drives the hardware
22d1                    lcdnibble: ; nibble to send is in a
22d1 36                         psha                            ; save nibble value.
22d2 96 32                      ldaa   PORTK                    ; get LCD port image.
22d4 84 03                      anda   #$03                     ; need low 2 bits.
22d6 aa b0                      oraa   1,sp+                    ; add in low 4 bits. 
22d8 5a 32                      staa   PORTK                    ; output data          
22da 4c 32 02                   bset    PORTK,#ENABLE   ; ENABLE=high
22dd a7                         nop
22de a7                         nop                     ; make pulse 250nsec wide
22df 4d 32 02                   bclr    PORTK,#ENABLE   ; ENABLE=low
22e2 3d                         rts
                        
                        #ifdef STEPPER_MOTOR
22e3                    tc0isr: ; 1ms Timer interrupt
22e3 dc 50                      ldd     TC0
22e5 c3 5d c0                   addd    #24000
22e8 5c 50                      std     TC0
22ea f7 10 00                   tst     running
22ed 26 10                      bne     t1
22ef 79 02 58                   clr     PTP             ; force drive off
22f2 79 00 01                   clr     PORTB
22f5 18 03 00 00 10 04          movw    #0 fraction     ; just in case, clear these
22fb 79 10 03                   clr     phase
22fe 0b                         rti
22ff 07 20              t1:     bsr     set_motor       ; set current position
2301 f6 10 02                   ldab    speed           ; look up in speed table
2304 58                         lslb                    ; multiply index by 2
2305 b7 15                      tfr     b x
2307 ec e2 24 27                ldd     speed_table,x
230b f3 10 04                   addd    fraction
230e 7c 10 04                   std     fraction
2311 24 08                      bcc     t2              ; done if no carry
2313 f7 10 01                   tst     reverse         ; if reverse, decrement phase
2316 26 04                      bne     t3
2318 72 10 03                   inc     phase
231b 0b                 t2:     rti
231c 73 10 03           t3:     dec     phase
231f 20 fa                      bra     t2
                        
2321                    set_motor:      ; subroutine to set motor controller to correct phase
2321 f6 10 03                   ldab    phase
2324 c4 03                      andb    #3      ; ignore all but 2 LSBs
2326 58                         lslb            ; multiply by 2
2327 b7 15                      tfr     b x
2329 f7 10 01                   tst     reverse
232c 26 15                      bne     set_motor_reverse
232e a6 e2 24 18                ldaa    fmotion+1,x ; for display not motor
2332 c7                         clrb
2333 49                         lsrd
2334 49                         lsrd
2335 ea e2 24 17                orab    fmotion,x 
2339 5b 01                      stab    PORTB
233b e6 e2 24 18                ldab    fmotion+1,x
233f 7b 02 58                   stab    PTP
2342 3d                         rts
2343                    set_motor_reverse:
2343 a6 e2 24 20                ldaa    bmotion+1,x
2347 c7                         clrb
2348 49                         lsrd
2349 49                         lsrd
234a ea e2 24 1f                orab    bmotion,x 
234e 5b 01                      stab    PORTB
2350 e6 e2 24 20                ldab    bmotion+1,x
2354 7b 02 58                   stab    PTP
2357 3d                         rts
                        #endif
                        
                        ; 
                        ; Tables and other constants
                        ;
                        
2358                    inidsp: 
2358 33                         fcb     $33             ; reset (4 nibble sequence)  
2359 32                         fcb     $32             ; reset 
235a 28                         fcb     $28             ; 4bit, 2 line, 5X7 dot
235b 06                         fcb     $06             ; cursor increment, disable display shift
235c 0c                         fcb     $0c             ; display on, cursor off, no blinking
235d 01                         fcb     $01             ; clear display memory, set cursor to home pos
                        
235e 46 6f 72 77 61 72  fmsg:   fcc     /Forward /
     64 20
2366 00                         db      0
                        
2367 42 61 63 6b 77 61  bmsg:   fcc     /Backward /
     72 64 20
2370 00                         db      0
                        
2371 4f 46 46 20 20 20  omsg:   fcc     /OFF       /
     20 20 20 20
237b 00                         db      0
                        
237c 20 2a 49 4e 53 54  imsg:   fcc     / *INSTRUCTIONS* /
     52 55 43 54 49 4f
     4e 53 2a 20
238c 00                         db      0
238d 30 2d 39 20 66 6f  ins1:   fcc     /0-9 for speed   /
     72 20 73 70 65 65
     64 20 20 20
239d 00                         db      0
239e 2a 20 66 6f 72 20  ins2:   fcc     /* for forward   /
     66 6f 72 77 61 72
     64 20 20 20
23ae 00                         db      0
23af 23 20 66 6f 72 20  ins3:   fcc     /# for backward  /
     62 61 63 6b 77 61
     72 64 20 20
23bf 00                         db      0
23c0 44 20 66 6f 72 20  ins4:   fcc     /D for OFF       /
     4f 46 46 20 20 20
     20 20 20 20
23d0 00                         db      0
23d1 48 45 4c 50 20 2d  ins5:   fcc     /HELP - keypad A /
     20 6b 65 79 70 61
     64 20 41 20
23e1 00                         db      0
23e2 20 20 20 20 20 20  insc:   fcc     /                /
     20 20 20 20 20 20
     20 20 20 20
23f2 00                         db      0
                        
23f3                    valtbl: ; Each table column represents a keyboard scan row, while the table rows represent
                                ; the scan values (rows of keys) - only rows 7, 11, 13, and 14 are valid
                                ;       (A321)(B654)(C987)(D#0*)
                        ;       db      -1,-1,-1,-1
                        ;       db      -1,-1,-1,-1
                        ;       db      -1,-1,-1,-1
                        ;       db      -1,-1,-1,-1
                        ;       db      -1,-1,-1,-1
                        ;       db      -1,-1,-1,-1
                        ;       db      -1,-1,-1,-1
23f3 1f 00 11 0d                db      $1f,0,$11,$d    ; scan value 7  (0111) * 0 # D
23f7 ff ff ff ff                db      -1,-1,-1,-1
23fb ff ff ff ff                db      -1,-1,-1,-1
23ff ff ff ff ff                db      -1,-1,-1,-1
2403 07 08 09 0c                db      7,8,9,$c        ; scan value 11 (1011) 7 8 9 C
2407 ff ff ff ff                db      -1,-1,-1,-1
240b 04 05 06 0b                db      4,5,6,$b        ; scan value 13 (1101) 4 5 6 B
240f 01 02 03 0a                db      1,2,3,$a        ; scan value 14 (1110) 1 2 3 A
2413 ff ff ff ff                db      -1,-1,-1,-1
                        
                        #ifdef STEPPER_MOTOR
                        ; The goal in these tables is to move smoothly from one phase to the
                        ; next by only changing the MOT levels while the output is disabled.
                        ; Separate tables are necessary for the different directions to achieve
                        ; this.
2417                    fmotion: ; Forward motion table Port B, Port P pairs
2417 09 01                      db      MOT1+MOT4,EN12  ; + X
2419 05 02                      db      MOT1+MOT3,EN34  ; x +
241b 06 01                      db      MOT2+MOT3,EN12  ; - x
241d 0a 02                      db      MOT2+MOT4,EN34  ; x -
241f                    bmotion: ; Backwards motion, same outputs
241f 05 01                      db      MOT1+MOT3,EN12  ; + X
2421 06 02                      db      MOT2+MOT3,EN34  ; x +
2423 0a 01                      db      MOT2+MOT4,EN12  ; - x
2425 09 02                      db      MOT1+MOT4,EN34  ; x -
                        ; Lookup table of value to add to fraction. We need to get to 65536 to
                        ; move to next phase. Fraction is incremented by this value every millisecond.
2427                    speed_table: 
2427 00 00                      dw      0       ; setting of 0
2429 02 8f                      dw      10*65536/1000   ; setting of 1 (10 phases per second)
242b 05 1e                      dw      20*65536/1000
242d 07 ae                      dw      30*65536/1000
242f 0a 3d                      dw      40*65536/1000
2431 0c cc                      dw      50*65536/1000
2433 0f 5c                      dw      60*65536/1000
2435 11 eb                      dw      70*65536/1000
2437 14 7a                      dw      80*65536/1000
2439 17 0a                      dw      90*65536/1000
                        #endif
                                end

Executed: Sun Jun 10 09:52:35 2007
Total cycles: 1121, Total bytes: 1083
Total errors: 0, Total warnings: 0
